{"task_id": "mux2to1v", "completion": "always @(posedge clk)\n  case (sel)\n    1'b0: y = a;\n    1'b1: y = b;\n  endcase\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1v", "completion": "always @(posedge clk)\n    out = sel ? b : a;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1v", "completion": "always @(posedge clk) begin\n    if (sel == 0) \n        out = a; \n    else \n        out = b; \nend\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1v", "completion": "wire out;\nreg out;\nreg a, b, sel;\n\nalways @(posedge clk)\n    if (sel == 0)\n        out <= a;\n    else\n        out <= b;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "mux2to1v", "completion": "always @(posedge clk) begin\n    if (sel == 1'b0) \n        y <= a;\n    else \n        y <= b;\nend", "result": "failed: syntax error.", "passed": false}
{"task_id": "m2014_q6b", "completion": "always @(posedge clk)\n    case (y)\n    3'b000: Y2 <= (x) ? 1'b0 : 1'b0;\n    3'b001: Y2 <= (x) ? 1'b1 : 1'b1;\n    3'b010: Y2 <= (x) ? 1'b1 : 1'b0;\n    3'b011: Y2 <= (x) ? 1'b0 : 1'b1;\n    3'b100: Y2 <= (x) ? 1'b1 : 1'b1;\n    3'b101: Y2 <= (x) ? 1'b0 : 1'b1;\n    default: Y2 <= 1'b0;\nendcase\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6b", "completion": "reg Y2, Y1, Y0, next_Y2, next_Y1, next_Y0;\nwire clk, reset, X;\n\nalways @(posedge clk, posedge reset)\nif (reset) begin\n    Y2 <= 0;\n    Y1 <= 0;\n    Y0 <= 0;\nend else begin\n    Y2 <= next_Y2;\n    Y1 <= next_Y1;\n    Y0 <= next_Y0;\nend\n\nalways @(*)\ncase ({Y2, Y1, Y0})\n    3'b000: begin\n        if (~X) next_Y2 = 0;\n        else next_Y2 = 0;\n    end\n    3'b001: begin\n        if (~X) next_Y2 = 0;\n        else next_Y2 = 1;\n    end\n    3'b010: begin\n        if (~X) next_Y2 = 0;\n        else next_Y2 = 1;\n    end\n    3'b011: begin\n        if (~X) next_Y2 = 0;\n        else next_Y2 = 1;\n    end\n    3'b100: begin\n        if (~X) next_Y2 = X;\n        else next_Y2 = 1;\n    end\n    3'b101: begin\n        if (~X) next_Y2 = 0;\n        else next_Y2 = 1;\n    end\nendcase\n\nassign Y2 = next_Y2;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6b", "completion": "always @(posedge clk) \n    begin \n        case ({y[2], y[1], y[0]})\n            3'b000: Y2 <= 1'b1; \n            3'b001: Y2 <= 1'b0; \n            3'b010: Y2 <= y[0]; \n            3'b011: Y2 <= 1'b1; \n            3'b100: Y2 <= y[0]; \n            3'b101: Y2 <= 1'b0; \n            3'b110: Y2 <= 1'b1; \n            3'b111: Y2 <= y[0]; \n        endcase \n    end \nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6b", "completion": "always @(posedge clk)\n    case (y)\n        3'b000: Y2 <= 0;\n        3'b001: Y2 <= 0;\n        3'b010: Y2 <= x ? 1 : 0;\n        3'b011: Y2 <= x ? 1 : 0;\n        3'b100: Y2 <= 1;\n        3'b101: Y2 <= x ? 0 : 1;\n        3'b110: Y2 <= 0;\n        3'b111: Y2 <= x ? 1 : 0;\n    endcase\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q6b", "completion": "reg y1, y2, y3, next_y1, next_y2, next_y3;\nalways @(posedge clk) begin\n    {y1, y2, y3} <= {next_y1, next_y2, next_y3};\nend\nassign next_y2 = (y1 & y2 & ~y3 & ~x) | (y1 & ~y2 & ~y3 & x) | (~y1 & y2 & y3 & ~x) | (~y1 & ~y2 & y3 & x) | (~y1 & y2 & ~y3 & x) | (~y1 & ~y2 & ~y3 & ~x);\nassign Y2 = y2;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ringer", "completion": "always @(posedge clk) begin\n    if (vibrate_mode) begin\n        motor <= 1;\n        ringer <= 0;\n    end else begin\n        motor <= 0;\n        ringer <= 1;\n    end\nend\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ringer", "completion": "always @(posedge clk) begin\n    if (vibrate_mode) \n        motor <= ring;\n    else \n        ringer <= ring;\nend\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ringer", "completion": "wire ringer, motor;\nreg ringer, motor;\n\nalways @(posedge clk) begin\n    if (vibrate_mode) begin\n        motor <= ring;\n        ringer <= 0;\n    end else begin\n        motor <= 0;\n        ringer <= ring;\n    end\nend\n\nassign ringer_out = ringer;\nassign motor_out = motor;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ringer", "completion": "always @(posedge clk) begin\n    if (vibrate_mode) \n        motor = ring; \n    else \n        ringer = ring; \n    motor = motor && vibrate_mode; \n    ringer = ringer && !vibrate_mode; \nend\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ringer", "completion": "always @(posedge clk) begin\n    if (vibrate_mode) \n        motor <= ring;\n    else \n        ringer <= ring;\nend\n\nassign motor = vibrate_mode && ring;\nassign ringer = ~vibrate_mode && ring;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "alwaysblock1", "completion": "wire and_out_assign;\nwire and_out_always;\n\nassign and_out_assign = a & b;\n\nalways @(*)\n    and_out_always = a & b;\n\nreg and_out_always_reg;\nalways @(posedge clk)\n    and_out_always_reg <= and_out_always;\n\nreg and_out_assign_reg;\nalways @(posedge clk)\n    and_out_assign_reg <= and_out_assign;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "alwaysblock1", "completion": "wire and_out_assign;\nwire and_out_always;\n\nassign and_out_assign = a & b;\n\nalways @(*) \n    and_out_always = a & b;\n\nreg and_out_reg;\n\nalways @(posedge clk) \n    and_out_reg <= a & b;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "alwaysblock1", "completion": "wire out_assign;\nwire out_always;\n\nassign out_assign = a & b;\n\nalways @(*) \n    out_always = a & b;\n\nassign out = out_assign & out_always;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "alwaysblock1", "completion": "wire out_assign;\nwire out_always;\n\nassign out_assign = a && b;\n\nalways @(*)\n    out_always = a && b;\n\nreg clk;\ninitial clk = 0;\nalways #5 clk = ~clk;\n\nalways @(posedge clk)\nbegin\n    if (a && b)\n        out_assign_reg <= 1'b1;\n    else\n        out_assign_reg <= 1'b0;\nend\n\nalways @(posedge clk)\nbegin\n    if (a && b)\n        out_always_reg <= 1'b1;\n    else\n        out_always_reg <= 1'b0;\nend\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "alwaysblock1", "completion": "reg out_assign;\nreg out_always;\n\nalways @(a, b) \nbegin\n    out_always = a & b;\nend\n\nassign out_assign = a & b;\n\nalways @(posedge clk)\n    begin\n    end \n\nassign out = out_assign;\nassign out2 = out_always;", "result": "failed: syntax error.", "passed": false}
{"task_id": "zero", "completion": "assign OUT = 1'b0;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "zero", "completion": "always @(posedge clk) begin\n    out <= 1'b0;\nend", "result": "failed: syntax error.", "passed": false}
{"task_id": "zero", "completion": "reg out;\n\nalways @(posedge clk)\nout <= 1'b0;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "zero", "completion": "assign out = 1'b0;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "zero", "completion": "assign out = 1'b0;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "circuit7", "completion": "reg q;\nalways @(posedge clk)\n    if (a)\n        q <= ~q;\n    else\n        q <= q;", "result": "failed: syntax error.", "passed": false}
{"task_id": "circuit7", "completion": "reg q;\nalways @(posedge clk) \n    q <= a;", "result": "failed: syntax error.", "passed": false}
{"task_id": "circuit7", "completion": "reg q;\nalways @(posedge clk)\n    q <= a;\nassign q_bar = ~q;", "result": "failed: syntax error.", "passed": false}
{"task_id": "circuit7", "completion": "always @(posedge clk) begin\n    if (a) q <= ~q;\nend\n\nendmodule", "result": "failed: 120 out of 123 samples.", "passed": false}
{"task_id": "circuit7", "completion": "reg q;\nalways @(posedge clk) \n    if (a) \n        q <= ~q;\n    else \n        q <= q;\nassign q_out = q;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2014_q5a", "completion": "always @(posedge clk or negedge reset)\nbegin\n    if (~reset)\n        state <= S0;\n    else\n        case (state)\n            S0:\n                if (x)\n                    state <= S1;\n                else\n                    state <= S0;\n            S1:\n                if (x)\n                    state <= S2;\n                else\n                    state <= S0;\n            S2:\n                if (x)\n                    state <= S1;\n                else\n                    state <= S0;\n        endcase\nend\n\nassign Z = (state == S1);\n\nreg [1:0] state;\nparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2014_q5a", "completion": "reg [1:0] current_state, next_state;\nparameter S0 = 2'b00, S1 = 2'b01, S2 = 2'b10, S3 = 2'b11;\n\nalways @(posedge clk or posedge reset)\n    if (reset) current_state <= S0;\n    else current_state <= next_state;\n\nalways @(current_state or x)\n    case (current_state)\n        S0: if (~x) next_state = S0; else next_state = S1;\n        S1: if (~x) next_state = S2; else next_state = S3;\n        S2: if (x) next_state = S2; else next_state = S1;\n        S3: if (~x) next_state = S0; else next_state = S3;\n    endcase\n\nassign Z = (current_state == S1 || current_state == S3);\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2014_q5a", "completion": "reg [1:0] state, next_state;\nreg Z, next_Z;\nreg x_reg, x_reg_reg;\n\nalways @(posedge clk or posedge reset)\n    if (reset) begin\n        state <= 0;\n        Z <= 0;\n        x_reg <= 0;\n        x_reg_reg <= 0;\n    end else begin\n        state <= next_state;\n        Z <= next_Z;\n        x_reg <= x;\n        x_reg_reg <= x_reg;\n    end\n\nalways @*\n    case (state)\n        0: begin\n            if (~x_reg) begin\n                next_state = 0;\n                next_Z = 0;\n            end else begin\n                next_state = 1;\n                next_Z = 1;\n            end\n        end\n        1: begin\n            if (~x_reg) begin\n                next_state = 2;\n                next_Z = ~x_reg_reg;\n            end else begin\n                next_state = 1;\n                next_Z = x_reg_reg;\n            end\n        end\n        2: begin\n            next_state = 0;\n            next_Z = x_reg_reg;\n        end\n    endcase\n\nassign Z_out = Z;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2014_q5a", "completion": "reg [1:0] state, next_state;\nreg Z, z_next;\n\nalways @(posedge clk or posedge reset)\n    if (reset) \n        state <= 2'b00;\n    else \n        state <= next_state;\n\nalways @*\n    case (state)\n        2'b00: begin\n                    if (~x) \n                        next_state = 2'b00;\n                    else \n                        next_state = 2'b01;\n                    z_next = x;\n                end\n        2'b01: begin\n                    if (~x) \n                        next_state = 2'b10;\n                    else \n                        next_state = 2'b01;\n                    z_next = ~x;\n                end\n        2'b10: begin\n                    if (~x) \n                        next_state = 2'b00;\n                    else \n                        next_state = 2'b10;\n                    z_next = ~x;\n                end\n        default: begin\n                    next_state = 2'b00;\n                    z_next = x;\n                end\n    endcase\n\nassign Z = z_next;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "ece241_2014_q5a", "completion": "reg [1:0] state, next_state;\nreg Z, next_Z;\nreg x_reg;\n\nalways @(posedge clk or negedge reset)\n    if (~reset)\n        state <= 2'b00;\n    else\n        state <= next_state;\n\nalways @(posedge clk)\n    x_reg <= x;\n\nalways @(*)\n    case (state)\n        2'b00: begin\n            if (~x_reg)\n                next_state = 2'b01;\n            else\n                next_state = 2'b00;\n            next_Z = 1'b0;\n        end\n        2'b01: begin\n            if (~x_reg)\n                next_state = 2'b11;\n            else\n                next_state = 2'b01;\n            next_Z = 1'b1;\n        end\n        2'b10: begin\n            if (~x_reg)\n                next_state = 2'b11;\n            else\n                next_state = 2'b10;\n            next_Z = 1'b1;\n        end\n        2'b11: begin\n            if (~x_reg)\n                next_state = 2'b10;\n            else\n                next_state = 2'b11;\n            next_Z = 1'b0;\n        end\n    endcase\n\nalways @(posedge clk)\n    Z <= next_Z;\n\nassign Z_out = Z;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "completion": "reg [1:0] current_state, next_state;\nassign next_state = (in) ? {state_B[state], state_D[state], state_C[state], state_A[state]} : {state_A[state], state_B[state], state_C[state], state_D[state]};\nalways @(posedge clk or negedge reset)\n    if (!reset) current_state <= 2'b00;\n    else current_state <= next_state;\nassign out = (current_state == 2'b11);\nalways @* case (current_state)\n    2'b00: state_A = 1; state_B = 0; state_C = 0; state_D = 0;\n    2'b01: state_A = 0; state_B = 1; state_C = 0; state_D = 0;\n    2'b10: state_A = 0; state_B = 0; state_C = 1; state_D = 0;\n    2'b11: state_A = 0; state_B = 0; state_C = 0; state_D = 1;\n    default: state_A = 0; state_B = 0; state_C = 0; state_D = 0;\nendcase\nendmodule", "result": "failed: syntax error.", "passed": false}
{"task_id": "fsm3", "completion": "reg [1:0] current_state, next_state;\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\nalways @(posedge clk, posedge reset)\nif (reset) current_state <= A;\nelse current_state <= next_state;\n\nalways @(*)\ncase (current_state)\nA: \n    if (in) next_state <= B; \n    else next_state <= A;\nB: \n    if (in) next_state <= B; \n    else next_state <= C;\nC: \n    if (in) next_state <= D; \n    else next_state <= A;\nD: \n    if (in) next_state <= B; \n    else next_state <= C;\ndefault: next_state <= A;\nendcase\n\nassign out = (current_state == D);\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "completion": "reg [1:0] cs, ns;\nalways @(posedge clk, posedge reset)\nif (reset)\n    cs <= 2'b00;\nelse\n    cs <= ns;\n\nalways @*\ncase (cs)\n    2'b00:begin\n        if (~in)\n            ns <= 2'b00;\n        else\n            ns <= 2'b01;\n        out <= 1'b0;\n    end\n    2'b01: begin\n        if (~in)\n            ns <= 2'b10;\n        else\n            ns <= 2'b01;\n        out <= 1'b0;\n    end\n    2'b10: begin\n        if (~in)\n            ns <= 2'b00;\n        else\n            ns <= 2'b11;\n        out <= 1'b0;\n    end\n    2'b11: begin\n        if (~in)\n            ns <= 2'b10;\n        else\n            ns <= 2'b01;\n        out <= 1'b1;\n    end\nendcase\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "fsm3", "completion": "reg [1:0] state, next_state;\nparameter A = 2'b00, B = 2'b01, C = 2'b10, D = 2'b11;\n\nalways @(posedge clk or negedge reset)\nbegin\n    if (~reset)\n        state <= A;\n    else\n        state <= next_state;\nend\n\nalways @*\ncase (state)\n    A: next_state = in ? B : A;\n    B: next_state = in ? B : C;\n    C: next_state = in ? D : A;\n    D: next_state = in ? B : C;\nendcase\n\nassign output = (state == D);\n\nendmodule", "result": "failed: syntax error.", "passed": false}
{"task_id": "fsm3", "completion": "reg [1:0] state, next_state;\n\nalways @(posedge clk or posedge rst)\n    if (rst)\n        state <= 2'b00;\n    else\n        state <= next_state;\n\nalways @(*)\n    case (state)\n        2'b00: begin\n            case (in)\n                1'b0: next_state = 2'b00;\n                1'b1: next_state = 2'b01;\n            endcase\n        end\n        2'b01: begin\n            case (in)\n                1'b0: next_state = 2'b10;\n                1'b1: next_state = 2'b01;\n            endcase\n        end\n        2'b10: begin\n            case (in)\n                1'b0: next_state = 2'b00;\n                1'b1: next_state = 2'b11;\n            endcase\n        end\n        2'b11: begin\n            case (in)\n                1'b0: next_state = 2'b10;\n                1'b1: next_state = 2'b01;\n            endcase\n        end\n    endcase\n\nassign out = (state == 2'b11) ? 1'b1 : 1'b0;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "completion": "reg [7:0] reversed_byte;\nreg [31:0] reversed_word;\n\nalways @(posedge clk) begin\n    reversed_byte[7:0] = original_word[7:0];\n    reversed_byte[15:8] = original_word[23:16];\n    reversed_byte[23:16] = original_word[15:8];\n    reversed_byte[31:24] = original_word[31:24];\n    reversed_word = {reversed_byte[31:24], reversed_byte[23:16], reversed_byte[15:8], reversed_byte[7:0]};\nend\n\nassign output_word = reversed_word;\n\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "completion": "always @(posedge clk) begin\n    assign out[7:0] = in[24:31];\n    assign out[8:15] = in[16:23];\n    assign out[16:23] = in[8:15];\n    assign out[24:31] = in[0:7];\nend\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "completion": "always @(posedge clk) begin\n   assign reversed_data[31:24] = data[7:0];\n    assign reversed_data[23:16] = data[15:8];\n    assign reversed_data[15:8] = data[23:16];\n    assign reversed_data[7:0] = data[31:24];\nend\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "completion": "reg [31:0] reversed_data;\nalways @(posedge clk) begin\n    reversed_data[7:0] <= data[31:24];\n    reversed_data[15:8] <= data[23:16];\n    reversed_data[23:16] <= data[15:8];\n    reversed_data[31:24] <= data[7:0];\nend\nassign out_data = reversed_data;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "vector2", "completion": "reg [7:0] reversed_bytes [3:0];\nalways @(posedge clk) begin\n    reversed_bytes[0] <= input[7:0];\n    reversed_bytes[1] <= input[15:8];\n    reversed_bytes[2] <= input[23:16];\n    reversed_bytes[3] <= input[31:24];\n    output <= {reversed_bytes[3], reversed_bytes[2], reversed_bytes[1], reversed_bytes[0]};\nend\nendmodule", "result": "failed: syntax error.", "passed": false}
{"task_id": "m2014_q4c", "completion": "reg q;\nalways @(posedge clk, posedge reset)\n    if (reset)\n        q <= 0;\n    else\n        q <= d;\nassign q_out = q;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4c", "completion": "reg Q;\nreg Qbar;\n\nalways @(posedge clk or posedge reset) \nbegin \n    if (reset) \n    begin \n        Q <= 1'b0; \n        Qbar <= 1'b1; \n    end \n    else \n    begin \n        Q <= D; \n        Qbar <= ~D; \n    end \nend \n\nassign Qout = Q;\nassign Qbarout = Qbar;\nendmodule", "result": "failed: compile error.", "passed": false}
{"task_id": "m2014_q4c", "completion": "reg q;\nalways @(posedge clk, posedge reset)\n    if (reset)\n        q <= 0;\n    else\n        q <= d;", "result": "failed: syntax error.", "passed": false}
{"task_id": "m2014_q4c", "completion": "always @(posedge clk or posedge reset)\nif (reset)\n    q <= 0;\nelse\n    q <= d;", "result": "failed: syntax error.", "passed": false}
{"task_id": "m2014_q4c", "completion": "always @(posedge clk or posedge reset) begin\n    if (reset) \n        q <= 1'b0;\n    else \n        q <= d;\nend", "result": "failed: syntax error.", "passed": false}
