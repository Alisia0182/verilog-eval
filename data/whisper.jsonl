{"task_id": "gatesv", "completion": "reg [2:0] out_both;\nreg [3:1] out_any;\nreg [3:0] out_different;\n\nalways @ (posedge clk)\nbegin\n    out_both <= in[2:0];\n    out_any <= in | 4'b1110;\n    out_different <= in ^ 4'b1111;\nend\n\nendmodule"}
{"task_id": "gatesv", "completion": "reg [2:0] out_both_reg;\nreg [3:1] out_any_reg;\nreg [3:0] out_different_reg;\n\nalways @(posedge clk)\nbegin\n    out_both_reg <= in[2:0];\n    out_any_reg <= in | 3'b1110;\n    out_different_reg <= in ^ 4'b1111;\nend\n\nassign out_both = out_both_reg;\nassign out_any = out_any_reg;\nassign out_different = out_different_reg;\nendmodule"}
{"task_id": "rotate100", "completion": "always @(posedge clk)\nbegin\n    if (load)\n    begin\n        case (ena)\n            2'b00: q <= data;\n            2'b01: q <= q & data;\n            2'b10: q <= q | data;\n            2'b11: q <= q ^ data;\n        endcase\n    end\nendmodule"}
{"task_id": "rotate100", "completion": "reg [99:0] memory [3:0];\n\nalways @(posedge clk) begin\n    if (load) begin\n        case (ena)\n            2'b00: memory[0] <= data;\n            2'b01: memory[1] <= data;\n            2'b10: memory[2] <= data;\n            2'b11: memory[3] <= data;\n            default: memory[0] <= data;\n        endcase\n    end\nend\n\nalways @(posedge clk) begin\n    case (ena)\n        2'b00: q <= memory[0];\n        2'b01: q <= memory[1];\n        2'b10: q <= memory[2];\n        2'b11: q <= memory[3];\n        default: q <= memory[0];\n    endcase\nend\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "completion": "reg B3_next, S_next, S1_next, Count_next, Wait_next, done, counting, shift_ena;\n\nalways @(posedge clk) begin\n    if (ack && done_counting)\n        done <= 1;\n    else\n        done <= 0;\n        \n    if (ack && !done_counting)\n        counting <= 1;\n    else\n        counting <= 0;\n        \n    if (state[0])\n        B3_next <= 1;\n    else\n        B3_next <= 0;\n        \n    if (state[1])\n        S_next <= 1;\n    else\n        S_next <= 0;\n        \n    if (state[2])\n        S1_next <= 1;\n    else\n        S1_next <= 0;\n        \n    if (state[3])\n        Count_next <= 1;\n    else\n        Count_next <= 0;\n        \n    if (state[4])\n        Wait_next <= 1;\n    else\n        Wait_next <= 0;\n        \n    if (state[5])\n        shift_ena <= 1;\n    else\n        shift_ena <= 0;\nend\n\nendmodule"}
{"task_id": "review2015_fsmonehot", "completion": "assign B3_next = state[3];\nassign S_next = state[8];\nassign S1_next = state[9];\nassign Count_next = (state == 10'b0000000010) ? 1'b1 : 1'b0;\nassign Wait_next = (state == 10'b0000000001) ? 1'b1 : 1'b0;\nassign done = done_counting;\nassign counting = (state != 10'b0000000000) ? 1'b1 : 1'b0;\nassign shift_ena = ack;\nendmodule"}
{"task_id": "dff8ar", "completion": "always @(posedge clk or posedge areset)\nbegin\n    if (areset)\n        q <= 8'b0;\n    else\n        q <= d;\nend\nendmodule"}
{"task_id": "dff8ar", "completion": "reg [7:0] q_reg;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset)\n        q_reg <= 8'd0;\n    else\n        q_reg <= d;\nend\n\nassign q = q_reg;\n\nendmodule"}
{"task_id": "kmap3", "completion": "always @(posedge clk) begin\n    if (a && b)\n        out <= c && d;\n    else if (a || b)\n        out <= c || d;\n    else\n        out <= c ^ d;\nend\nendmodule"}
{"task_id": "kmap3", "completion": "always @(posedge clk)\nbegin\n    if (a & b | c & d)\n        out <= 1;\n    else\n        out <= 0;\nend\nendmodule"}
{"task_id": "lemmings1", "completion": "reg [1:0] state, next_state;\nparameter STATE_IDLE = 2'b00;\nparameter STATE_WALK_LEFT = 2'b01;\nparameter STATE_WALK_RIGHT = 2'b10;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= STATE_IDLE;\n    end else begin\n        state <= next_state;\n    end\nend\n\nalways @(state) begin\n    case (state)\n        STATE_IDLE: begin\n            if (bump_left) begin\n                next_state <= STATE_WALK_RIGHT;\n            end else if (bump_right) begin\n                next_state <= STATE_WALK_LEFT;\n            end else begin\n                next_state <= STATE_IDLE;\n            end\n        end\n        STATE_WALK_LEFT: begin\n            if (bump_left) begin\n                next_state <= STATE_WALK_RIGHT;\n            end else begin\n                next_state <= STATE_IDLE;\n            end\n        end\n        STATE_WALK_RIGHT: begin\n            if (bump_right) begin\n                next_state <= STATE_WALK_LEFT;\n            end else begin\n                next_state <= STATE_IDLE;\n            end\n        end\n        default: next_state <= STATE_IDLE;\n    endcase\nend\n\nassign walk_left = (state == STATE_WALK_LEFT);\nassign walk_right = (state == STATE_WALK_RIGHT);\n\nendmodule"}
{"task_id": "lemmings1", "completion": "reg state, next_state;\nreg [1:0] counter;\nwire left_bump, right_bump;\n\nassign left_bump = areset & bump_left;\nassign right_bump = areset & bump_right;\n\nalways @(posedge clk or posedge areset) begin\n    if (areset) begin\n        state <= 2'b00;\n        counter <= 2'b00;\n    end\n    else begin\n        state <= next_state;\n        counter <= counter + 1;\n    end\nend\n\nalways @(state, counter, left_bump, right_bump) begin\n    case (state)\n        2'b00: begin\n            walk_left <= 1'b0;\n            walk_right <= 1'b0;\n            if (left_bump) next_state <= 2'b01;\n            else if (right_bump) next_state <= 2'b10;\n            else next_state <= 2'b00;\n        end\n        2'b01: begin\n            walk_left <= 1'b1;\n            walk_right <= 1'b0;\n            if (counter == 2'b11) next_state <= 2'b00;\n            else next_state <= 2'b01;\n        end\n        2'b10: begin\n            walk_left <= 1'b0;\n            walk_right <= 1'b1;\n            if (counter == 2'b11) next_state <= 2'b00;\n            else next_state <= 2'b10;\n        end\n        default: begin\n            walk_left <= 1'b0;\n            walk_right <= 1'b0;\n            next_state <= 2'b00;\n        end\n    endcase\nend\n\nendmodule"}
{"task_id": "2013_q2afsm", "completion": "reg [3:1] g;\n\nalways @(posedge clk or negedge resetn)\nbegin\n    if (~resetn)\n        g <= 3'b000;\n    else\n        case (r)\n            3'b001: g <= 3'b001;\n            3'b010: g <= 3'b010;\n            3'b011: g <= 3'b011;\n            default: g <= 3'b000;\n        endcase\nend\n\nendmodule"}
{"task_id": "2013_q2afsm", "completion": "reg [3:1] g;\n\nalways @(posedge clk or negedge resetn)\nbegin\n    if (~resetn)\n        g <= 3'b000;\n    else\n    begin\n        case (r)\n            3'b001: g <= 3'b001;\n            3'b010: g <= 3'b010;\n            3'b011: g <= 3'b011;\n            default: g <= 3'b000;\n        endcase\n    end\nend\n\nendmodule"}
{"task_id": "fsm_hdlc", "completion": "reg state, next_state;\nreg [1:0] count;\n\nparameter S0 = 2'b00;\nparameter S1 = 2'b01;\nparameter S2 = 2'b10;\nparameter S3 = 2'b11;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset) begin\n        state <= S0;\n        count <= 2'b00;\n    end else begin\n        state <= next_state;\n        count <= count + 1;\n    end\nend\n\nalways @(state, count, in) begin\n    case(state)\n        S0: begin\n            if (count == 2'b00)\n                next_state = S1;\n            else\n                next_state = S0;\n        end\n        S1: begin\n            if (count == 2'b01)\n                next_state = S2;\n            else\n                next_state = S1;\n        end\n        S2: begin\n            if (count == 2'b10)\n                next_state = S3;\n            else\n                next_state = S2;\n        end\n        S3: begin\n            next_state = S0;\n        end\n        default: next_state = S0;\n    endcase\nend\n\nassign disc = (state == S3);\nassign flag = (state == S2);\nassign err = (state == S1) && in;\nendmodule"}
{"task_id": "fsm_hdlc", "completion": "reg [2:0] state, next_state;\n\n// State definitions\nparameter IDLE = 3'b000;\nparameter CHECK = 3'b001;\nparameter DETECT = 3'b010;\nparameter ERROR = 3'b011;\n\n// State transition always block\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// State logic always block\nalways @(*) begin\n    case (state)\n        IDLE: begin\n            if (in)\n                next_state = CHECK;\n            else\n                next_state = IDLE;\n        end\n        CHECK: begin\n            if (!in)\n                next_state = DETECT;\n            else\n                next_state = CHECK;\n        end\n        DETECT: begin\n            if (in)\n                next_state = ERROR;\n            else\n                next_state = IDLE;\n        end\n        ERROR: begin\n            next_state = IDLE;\n        end\n        default: next_state = IDLE;\n    endcase\nend\n\n// Output logic\nassign disc = (state == DETECT);\nassign flag = (state == ERROR);\nassign err = (state == ERROR);\n\nendmodule"}
{"task_id": "bugs_mux2", "completion": "always @(posedge sel)\nbegin\n    if(sel)\n        out <= a;\n    else\n        out <= b;\nend\n\nendmodule"}
{"task_id": "bugs_mux2", "completion": "reg [7:0] temp;\n\nalways @(posedge sel)\nbegin\n    if(sel)\n        temp <= a;\n    else\n        temp <= b;\nend\n\nalways @(posedge sel)\nbegin\n    if(sel)\n        out <= temp + 8'b00000001;\n    else\n        out <= temp - 8'b00000001;\nend\n\nendmodule"}
{"task_id": "review2015_count1k", "completion": "reg [3:0] count;\nreg [3:0] next_count;\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 4'b0000;\n    else\n        count <= next_count;\nend\nalways @* begin\n    next_count = count + 1;\nend\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q <= 10'b0000000000;\n    else if (count == 4'b1001)\n        q <= q + 1;\nend\nendmodule"}
{"task_id": "review2015_count1k", "completion": "reg [3:0] count;\nreg [9:0] q_next;\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        count <= 4'b0;\n    else if (count == 4'b1001)\n        count <= 4'b0;\n    else\n        count <= count + 1;\nend\n\nalways @(posedge clk or posedge reset) begin\n    if (reset)\n        q_next <= 10'd0;\n    else if (count == 4'b1001)\n        q_next <= q_next + 10'd1;\nend\n\nalways @(posedge clk) begin\n    if (count == 4'b1001)\n        q <= q_next;\nend\n\nendmodule"}
