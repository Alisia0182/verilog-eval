{"task_id": "gatesv", "prompt": "module top_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n", "canonical_solution": "\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput [3:0] in,\n\toutput [2:0] out_both,\n\toutput [3:1] out_any,\n\toutput [3:0] out_different\n);\n\n\tassign out_both = in[2:0] & in[3:1];\n\tassign out_any = in[2:0] | in[3:1];\n\tassign out_different = in^{in[0], in[3:1]};\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\tinput tb_match,\n\toutput logic [3:0] in,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tin <= 4'h3;\n\t\t@(negedge clk);\n\t\twavedrom_start();\n\t\t\t@(posedge clk) in <= 3;\n\t\t\t@(posedge clk) in <= 6;\n\t\t\t@(posedge clk) in <= 12;\n\t\t\t@(posedge clk) in <= 9;\n\t\t\t@(posedge clk) in <= 5;\n\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\tin <= $random;\n\t\trepeat(100) begin\n\t\t\t@(negedge clk) in <= $random;\n\t\t\t@(posedge clk) in <= $random;\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out_both;\n\t\tint errortime_out_both;\n\t\tint errors_out_any;\n\t\tint errortime_out_any;\n\t\tint errors_out_different;\n\t\tint errortime_out_different;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [3:0] in;\n\tlogic [2:0] out_both_ref;\n\tlogic [2:0] out_both_dut;\n\tlogic [3:1] out_any_ref;\n\tlogic [3:1] out_any_dut;\n\tlogic [3:0] out_different_ref;\n\tlogic [3:0] out_different_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,in,out_both_ref,out_both_dut,out_any_ref,out_any_dut,out_different_ref,out_different_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.in );\n\treference_module good1 (\n\t\t.in,\n\t\t.out_both(out_both_ref),\n\t\t.out_any(out_any_ref),\n\t\t.out_different(out_different_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.in,\n\t\t.out_both(out_both_dut),\n\t\t.out_any(out_any_dut),\n\t\t.out_different(out_different_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out_both) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_both\", stats1.errors_out_both, stats1.errortime_out_both);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_both\");\n\t\tif (stats1.errors_out_any) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_any\", stats1.errors_out_any, stats1.errortime_out_any);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_any\");\n\t\tif (stats1.errors_out_different) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out_different\", stats1.errors_out_different, stats1.errortime_out_different);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out_different\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_both_ref, out_any_ref, out_different_ref } === ( { out_both_ref, out_any_ref, out_different_ref } ^ { out_both_dut, out_any_dut, out_different_dut } ^ { out_both_ref, out_any_ref, out_different_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_both_ref !== ( out_both_ref ^ out_both_dut ^ out_both_ref ))\n\t\tbegin if (stats1.errors_out_both == 0) stats1.errortime_out_both = $time;\n\t\t\tstats1.errors_out_both = stats1.errors_out_both+1'b1; end\n\t\tif (out_any_ref !== ( out_any_ref ^ out_any_dut ^ out_any_ref ))\n\t\tbegin if (stats1.errors_out_any == 0) stats1.errortime_out_any = $time;\n\t\t\tstats1.errors_out_any = stats1.errors_out_any+1'b1; end\n\t\tif (out_different_ref !== ( out_different_ref ^ out_different_dut ^ out_different_ref ))\n\t\tbegin if (stats1.errors_out_different == 0) stats1.errortime_out_different = $time;\n\t\t\tstats1.errors_out_different = stats1.errors_out_different+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "rotate100", "prompt": "module top_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n", "canonical_solution": "\t\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena == 2'h1)\n\t\t\tq <= {q[0], q[99:1]};\n\t\telse if (ena == 2'h2)\n\t\t\tq <= {q[98:0], q[99]};\n\tend\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput load,\n\tinput [1:0] ena,\n\tinput [99:0] data,\n\toutput reg [99:0] q);\n\t\n\t\n\talways @(posedge clk) begin\n\t\tif (load)\n\t\t\tq <= data;\n\t\telse if (ena == 2'h1)\n\t\t\tq <= {q[0], q[99:1]};\n\t\telse if (ena == 2'h2)\n\t\t\tq <= {q[98:0], q[99]};\n\tend\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg load,\n\toutput reg[1:0] ena,\n\toutput reg[99:0] data\n);\n\n\talways @(posedge clk)\n\t\tdata <= {$random,$random,$random,$random};\n\t\n\tinitial begin\n\t\tload <= 1;\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\trepeat(4000) @(posedge clk, negedge clk) begin\n\t\t\tload <= !($random & 31);\n\t\t\tena <= $random;\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic load;\n\tlogic [1:0] ena;\n\tlogic [99:0] data;\n\tlogic [99:0] q_ref;\n\tlogic [99:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,load,ena,data,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.load,\n\t\t.ena,\n\t\t.data );\n\treference_module good1 (\n\t\t.clk,\n\t\t.load,\n\t\t.ena,\n\t\t.data,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.load,\n\t\t.ena,\n\t\t.data,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "review2015_fsmonehot", "prompt": "module top_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n", "canonical_solution": " \n\t parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n    input d,\n    input done_counting,\n    input ack,\n    input [9:0] state,    // 10-bit one-hot current state\n    output B3_next,\n    output S_next,\n    output S1_next,\n    output Count_next,\n    output Wait_next,\n    output done,\n    output counting,\n    output shift_ena\n );\n \n\t parameter S=0, S1=1, S11=2, S110=3, B0=4, B1=5, B2=6, B3=7, Count=8, Wait=9;\n\n\tassign B3_next = state[B2];\n\tassign S_next = state[S]&~d | state[S1]&~d | state[S110]&~d | state[Wait]&ack;\n\tassign S1_next = state[S]&d;\n\tassign Count_next = state[B3] | state[Count]&~done_counting;\n\tassign Wait_next = state[Count]&done_counting | state[Wait]&~ack;\n\n\tassign done = state[Wait];\n\tassign counting = state[Count];\n\tassign shift_ena = |state[B3:B0];\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg d, done_counting, ack,\n\toutput reg [9:0] state,\n\tinput tb_match\n);\n\tbit failed = 0;\n\tbit fail_onehot = 0;\n\t\n\talways @(posedge clk, negedge clk)\n\t\tif (!tb_match) \n\t\t\tfailed <= 1;\n\t\n\tinitial begin\n\t\t{d, done_counting, ack} <= 3'h0;\n\t\tstate <= 10'h0;\n\t\t\n\t\trepeat(300) @(posedge clk, negedge clk) begin\n\t\t\t{d, done_counting, ack} = $random;\n\t\t\tstate <= 1<< ($unsigned($random) % 10);\n\t\tend\n\n\t\t@(posedge clk) fail_onehot <= failed;\n\n\t\trepeat(3000) @(posedge clk, negedge clk) begin\n\t\t\t{d, done_counting, ack} = $random;\n\t\t\tstate <= $random;\n\t\tend\n\n\t\t\n\t\t@(posedge clk);\n\t\tif (!fail_onehot && failed) begin\n\t\t\t$display (\"Hint: Your circuit passed when given only one-hot inputs, but not with random inputs.\");\n\t\t\t$display (\"Hint: Are you doing something more complicated than deriving state transition equations by inspection?\\n\");\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_B3_next;\n\t\tint errortime_B3_next;\n\t\tint errors_S_next;\n\t\tint errortime_S_next;\n\t\tint errors_S1_next;\n\t\tint errortime_S1_next;\n\t\tint errors_Count_next;\n\t\tint errortime_Count_next;\n\t\tint errors_Wait_next;\n\t\tint errortime_Wait_next;\n\t\tint errors_done;\n\t\tint errortime_done;\n\t\tint errors_counting;\n\t\tint errortime_counting;\n\t\tint errors_shift_ena;\n\t\tint errortime_shift_ena;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic d;\n\tlogic done_counting;\n\tlogic ack;\n\tlogic [9:0] state;\n\tlogic B3_next_ref;\n\tlogic B3_next_dut;\n\tlogic S_next_ref;\n\tlogic S_next_dut;\n\tlogic S1_next_ref;\n\tlogic S1_next_dut;\n\tlogic Count_next_ref;\n\tlogic Count_next_dut;\n\tlogic Wait_next_ref;\n\tlogic Wait_next_dut;\n\tlogic done_ref;\n\tlogic done_dut;\n\tlogic counting_ref;\n\tlogic counting_dut;\n\tlogic shift_ena_ref;\n\tlogic shift_ena_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,d,done_counting,ack,state,B3_next_ref,B3_next_dut,S_next_ref,S_next_dut,S1_next_ref,S1_next_dut,Count_next_ref,Count_next_dut,Wait_next_ref,Wait_next_dut,done_ref,done_dut,counting_ref,counting_dut,shift_ena_ref,shift_ena_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.d,\n\t\t.done_counting,\n\t\t.ack,\n\t\t.state );\n\treference_module good1 (\n\t\t.d,\n\t\t.done_counting,\n\t\t.ack,\n\t\t.state,\n\t\t.B3_next(B3_next_ref),\n\t\t.S_next(S_next_ref),\n\t\t.S1_next(S1_next_ref),\n\t\t.Count_next(Count_next_ref),\n\t\t.Wait_next(Wait_next_ref),\n\t\t.done(done_ref),\n\t\t.counting(counting_ref),\n\t\t.shift_ena(shift_ena_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.d,\n\t\t.done_counting,\n\t\t.ack,\n\t\t.state,\n\t\t.B3_next(B3_next_dut),\n\t\t.S_next(S_next_dut),\n\t\t.S1_next(S1_next_dut),\n\t\t.Count_next(Count_next_dut),\n\t\t.Wait_next(Wait_next_dut),\n\t\t.done(done_dut),\n\t\t.counting(counting_dut),\n\t\t.shift_ena(shift_ena_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_B3_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"B3_next\", stats1.errors_B3_next, stats1.errortime_B3_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"B3_next\");\n\t\tif (stats1.errors_S_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"S_next\", stats1.errors_S_next, stats1.errortime_S_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"S_next\");\n\t\tif (stats1.errors_S1_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"S1_next\", stats1.errors_S1_next, stats1.errortime_S1_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"S1_next\");\n\t\tif (stats1.errors_Count_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Count_next\", stats1.errors_Count_next, stats1.errortime_Count_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Count_next\");\n\t\tif (stats1.errors_Wait_next) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"Wait_next\", stats1.errors_Wait_next, stats1.errortime_Wait_next);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"Wait_next\");\n\t\tif (stats1.errors_done) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"done\", stats1.errors_done, stats1.errortime_done);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"done\");\n\t\tif (stats1.errors_counting) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"counting\", stats1.errors_counting, stats1.errortime_counting);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"counting\");\n\t\tif (stats1.errors_shift_ena) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"shift_ena\", stats1.errors_shift_ena, stats1.errortime_shift_ena);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"shift_ena\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { B3_next_ref, S_next_ref, S1_next_ref, Count_next_ref, Wait_next_ref, done_ref, counting_ref, shift_ena_ref } === ( { B3_next_ref, S_next_ref, S1_next_ref, Count_next_ref, Wait_next_ref, done_ref, counting_ref, shift_ena_ref } ^ { B3_next_dut, S_next_dut, S1_next_dut, Count_next_dut, Wait_next_dut, done_dut, counting_dut, shift_ena_dut } ^ { B3_next_ref, S_next_ref, S1_next_ref, Count_next_ref, Wait_next_ref, done_ref, counting_ref, shift_ena_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (B3_next_ref !== ( B3_next_ref ^ B3_next_dut ^ B3_next_ref ))\n\t\tbegin if (stats1.errors_B3_next == 0) stats1.errortime_B3_next = $time;\n\t\t\tstats1.errors_B3_next = stats1.errors_B3_next+1'b1; end\n\t\tif (S_next_ref !== ( S_next_ref ^ S_next_dut ^ S_next_ref ))\n\t\tbegin if (stats1.errors_S_next == 0) stats1.errortime_S_next = $time;\n\t\t\tstats1.errors_S_next = stats1.errors_S_next+1'b1; end\n\t\tif (S1_next_ref !== ( S1_next_ref ^ S1_next_dut ^ S1_next_ref ))\n\t\tbegin if (stats1.errors_S1_next == 0) stats1.errortime_S1_next = $time;\n\t\t\tstats1.errors_S1_next = stats1.errors_S1_next+1'b1; end\n\t\tif (Count_next_ref !== ( Count_next_ref ^ Count_next_dut ^ Count_next_ref ))\n\t\tbegin if (stats1.errors_Count_next == 0) stats1.errortime_Count_next = $time;\n\t\t\tstats1.errors_Count_next = stats1.errors_Count_next+1'b1; end\n\t\tif (Wait_next_ref !== ( Wait_next_ref ^ Wait_next_dut ^ Wait_next_ref ))\n\t\tbegin if (stats1.errors_Wait_next == 0) stats1.errortime_Wait_next = $time;\n\t\t\tstats1.errors_Wait_next = stats1.errors_Wait_next+1'b1; end\n\t\tif (done_ref !== ( done_ref ^ done_dut ^ done_ref ))\n\t\tbegin if (stats1.errors_done == 0) stats1.errortime_done = $time;\n\t\t\tstats1.errors_done = stats1.errors_done+1'b1; end\n\t\tif (counting_ref !== ( counting_ref ^ counting_dut ^ counting_ref ))\n\t\tbegin if (stats1.errors_counting == 0) stats1.errortime_counting = $time;\n\t\t\tstats1.errors_counting = stats1.errors_counting+1'b1; end\n\t\tif (shift_ena_ref !== ( shift_ena_ref ^ shift_ena_dut ^ shift_ena_ref ))\n\t\tbegin if (stats1.errors_shift_ena == 0) stats1.errortime_shift_ena = $time;\n\t\t\tstats1.errors_shift_ena = stats1.errors_shift_ena+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "dff8ar", "prompt": "module top_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n", "canonical_solution": "\t\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput [7:0] d,\n\tinput areset,\n\toutput reg [7:0] q);\n\t\n\talways @(posedge clk, posedge areset)\n\t\tif (areset)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= d;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg [7:0] d, output areset,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\t\t\n);\n\n\treg reset;\n\tassign areset = reset;\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\t\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\td <= $random;\n\t\t@(negedge clk);\n\t\t@(negedge clk);\n\t\twavedrom_start(\"Asynchronous active-high reset\");\n\t\treset_test(1);\n\t\trepeat(7) @(negedge clk) d <= $random;\n\t\t@(posedge clk) reset <= 1;\n\t\t@(negedge clk) reset <= 0; d <= $random;\n\t\trepeat(2) @(negedge clk) d <= $random;\n\t\twavedrom_stop();\n\n\n\t\trepeat(400) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 15);\n\t\t\td <= $random;\n\t\tend\n\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic [7:0] d;\n\tlogic areset;\n\tlogic [7:0] q_ref;\n\tlogic [7:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,d,areset,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.d,\n\t\t.areset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.d,\n\t\t.areset,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.d,\n\t\t.areset,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "kmap3", "prompt": "module top_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n", "canonical_solution": "\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput a, \n\tinput b,\n\tinput c,\n\tinput d,\n\toutput reg out\n);\n\t\n    always @(*) begin\n        case({a,b,c,d})\n            4'h0: out = 0;\n            4'h1: out = 0;\n            4'h3: out = 1;\n            4'h2: out = 1;\n            4'h4: out = 1'bx;\n            4'h5: out = 0;\n            4'h7: out = 0;\n            4'h6: out = 0;\n            4'hc: out = 1;\n            4'hd: out = 1'bx;\n            4'hf: out = 1;\n            4'he: out = 1;\n            4'h8: out = 1;\n            4'h9: out = 1'bx;\n            4'hb: out = 1;\n            4'ha: out = 1;\n        endcase\n    end\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg a, b, c, d,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\tint count; count = 0;\n\t\t{a,b,c,d} <= 4'b0;\n\t\twavedrom_start();\n\t\trepeat(16) @(posedge clk)\n\t\t\t{a,b,c,d} <= count++;\t\t\n\t\t@(negedge clk) wavedrom_stop();\n\t\t\n\t\trepeat(200) @(posedge clk, negedge clk)\n\t\t\t{d,c,b,a} <= $urandom;\n\t\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic a;\n\tlogic b;\n\tlogic c;\n\tlogic d;\n\tlogic out_ref;\n\tlogic out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,a,b,c,d,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d );\n\treference_module good1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.a,\n\t\t.b,\n\t\t.c,\n\t\t.d,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "lemmings1", "prompt": "module top_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n", "canonical_solution": "\tparameter WL=0, WR=1;\n\treg state;\n\treg next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tWL: next = bump_left ? WR : WL;\n\t\t\tWR: next = bump_right ? WL: WR;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= WL;\n        else state <= next;\n\tend\n\t\t\n\tassign walk_left = (state==WL);\n\tassign walk_right = (state==WR);\n\n\t\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput areset,\n\tinput bump_left,\n\tinput bump_right,\n\toutput walk_left,\n\toutput walk_right\n);\n\tparameter WL=0, WR=1;\n\treg state;\n\treg next;\n    \n    always_comb begin\n\t\tcase (state)\n\t\t\tWL: next = bump_left ? WR : WL;\n\t\t\tWR: next = bump_right ? WL: WR;\n\t\tendcase\n    end\n    \n    always @(posedge clk, posedge areset) begin\n\t\tif (areset) state <= WL;\n        else state <= next;\n\tend\n\t\t\n\tassign walk_left = (state==WL);\n\tassign walk_right = (state==WR);\n\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic areset,\n\toutput logic bump_left,\n\toutput logic bump_right,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\treg reset;\n\tassign areset = reset;\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\t\n\tinitial begin\n\t\treset <= 1'b1;\n\t\t{bump_right, bump_left} <= 3'h3;\n\t\twavedrom_start(\"Asynchronous reset\");\n\t\treset_test(1);\n\t\trepeat(3) @(posedge clk);\n\t\t{bump_right, bump_left} <= 2;\n\t\trepeat(2) @(posedge clk);\n\t\t{bump_right, bump_left} <= 1;\n\t\trepeat(2) @(posedge clk);\n\t\twavedrom_stop();\n\t\t\n\t\t@(posedge clk);\n\t\trepeat(200) @(posedge clk, negedge clk) begin\n\t\t\t{bump_right, bump_left} <= $random & $random;\n\t\t\treset <= !($random & 31);\n\t\tend\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_walk_left;\n\t\tint errortime_walk_left;\n\t\tint errors_walk_right;\n\t\tint errortime_walk_right;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic areset;\n\tlogic bump_left;\n\tlogic bump_right;\n\tlogic walk_left_ref;\n\tlogic walk_left_dut;\n\tlogic walk_right_ref;\n\tlogic walk_right_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,areset,bump_left,bump_right,walk_left_ref,walk_left_dut,walk_right_ref,walk_right_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.areset,\n\t\t.bump_left,\n\t\t.bump_right );\n\treference_module good1 (\n\t\t.clk,\n\t\t.areset,\n\t\t.bump_left,\n\t\t.bump_right,\n\t\t.walk_left(walk_left_ref),\n\t\t.walk_right(walk_right_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.areset,\n\t\t.bump_left,\n\t\t.bump_right,\n\t\t.walk_left(walk_left_dut),\n\t\t.walk_right(walk_right_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_walk_left) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"walk_left\", stats1.errors_walk_left, stats1.errortime_walk_left);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"walk_left\");\n\t\tif (stats1.errors_walk_right) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"walk_right\", stats1.errors_walk_right, stats1.errortime_walk_right);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"walk_right\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { walk_left_ref, walk_right_ref } === ( { walk_left_ref, walk_right_ref } ^ { walk_left_dut, walk_right_dut } ^ { walk_left_ref, walk_right_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (walk_left_ref !== ( walk_left_ref ^ walk_left_dut ^ walk_left_ref ))\n\t\tbegin if (stats1.errors_walk_left == 0) stats1.errortime_walk_left = $time;\n\t\t\tstats1.errors_walk_left = stats1.errors_walk_left+1'b1; end\n\t\tif (walk_right_ref !== ( walk_right_ref ^ walk_right_dut ^ walk_right_ref ))\n\t\tbegin if (stats1.errors_walk_right == 0) stats1.errortime_walk_right = $time;\n\t\t\tstats1.errors_walk_right = stats1.errors_walk_right+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "2013_q2afsm", "prompt": "module top_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n", "canonical_solution": "\tparameter A=0, B=1, C=2, D=3;\n\treg [1:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (~resetn) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways@(state,r) begin\n\t\tcase (state)\n\t\t\tA: if (r[1]) next = B;\n\t\t\t   else if (r[2]) next = C;\n\t\t\t   else if (r[3]) next = D;\n\t\t\t   else next = A;\n\t\t\tB: next = r[1] ? B : A;\n\t\t\tC: next = r[2] ? C : A;\n\t\t\tD: next = r[3] ? D : A;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign g[1] = (state == B);\t\n\tassign g[2] = (state == C);\t\n\tassign g[3] = (state == D);\t\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput resetn,\n\tinput [3:1] r,\n\toutput [3:1] g\n);\n\tparameter A=0, B=1, C=2, D=3;\n\treg [1:0] state, next;\n\n\talways @(posedge clk) begin\n\t\tif (~resetn) state <= A;\n\t\telse state <= next;\n\tend\n\t\n\talways@(state,r) begin\n\t\tcase (state)\n\t\t\tA: if (r[1]) next = B;\n\t\t\t   else if (r[2]) next = C;\n\t\t\t   else if (r[3]) next = D;\n\t\t\t   else next = A;\n\t\t\tB: next = r[1] ? B : A;\n\t\t\tC: next = r[2] ? C : A;\n\t\t\tD: next = r[3] ? D : A;\n\t\t\tdefault: next = 'x;\n\t\tendcase\n\tend\n\t    \n\tassign g[1] = (state == B);\t\n\tassign g[2] = (state == C);\t\n\tassign g[3] = (state == D);\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic resetn,\n\toutput logic [3:1] r,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\treg reset;\n\tassign resetn = ~reset;\n\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\tr <= 0;\n\t\t@(posedge clk);\n\t\t\n\t\tr <= 1;\n\t\treset_test();\n\t\t\n\t\tr <= 0;\n\t\twavedrom_start(\"\");\n\t\t@(posedge clk) r <= 0;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 6;\n\t\t@(posedge clk) r <= 6;\n\t\t@(posedge clk) r <= 6;\n\t\t@(posedge clk) r <= 4;\n\t\t@(posedge clk) r <= 4;\n\t\t@(posedge clk) r <= 4;\n\t\t@(posedge clk) r <= 0;\n\t\t@(posedge clk) r <= 0;\n\t\t@(posedge clk) r <= 4;\n\t\t@(posedge clk) r <= 6;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 7;\n\t\t@(posedge clk) r <= 7;\n\t\t@(negedge clk);\n\t\twavedrom_stop();\n\t\t\n\t\t@(posedge clk);\n\t\treset <= 0;\n\t\t@(posedge clk);\n\t\t@(posedge clk);\n\t\t\n\t\trepeat(500) @(negedge clk) begin\n\t\t\treset <= ($random & 63) == 0;\n\t\t\tr <= $random;\n\t\tend\n\t\t\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_g;\n\t\tint errortime_g;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic resetn;\n\tlogic [3:1] r;\n\tlogic [3:1] g_ref;\n\tlogic [3:1] g_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,resetn,r,g_ref,g_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.resetn,\n\t\t.r );\n\treference_module good1 (\n\t\t.clk,\n\t\t.resetn,\n\t\t.r,\n\t\t.g(g_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.resetn,\n\t\t.r,\n\t\t.g(g_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_g) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"g\", stats1.errors_g, stats1.errortime_g);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"g\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { g_ref } === ( { g_ref } ^ { g_dut } ^ { g_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (g_ref !== ( g_ref ^ g_dut ^ g_ref ))\n\t\tbegin if (stats1.errors_g == 0) stats1.errortime_g = $time;\n\t\t\tstats1.errors_g = stats1.errors_g+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "fsm_hdlc", "prompt": "module top_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n", "canonical_solution": "\t\n\tparameter [3:0] S0=0, S1=1, S2=2, S3=3, S4=4, S5=5, S6=6, SERR=7, SDISC=8, SFLAG=9;\n\treg [3:0] state, next;\n\n\tassign disc = state == SDISC;\n\tassign flag = state == SFLAG;\n\tassign err = state == SERR;\n\t\n\talways @(posedge clk) begin\n\t\tcase (state)\n\t\t\tS0: state <= in ? S1 : S0;\n\t\t\tS1: state <= in ? S2 : S0;\n\t\t\tS2: state <= in ? S3 : S0;\n\t\t\tS3: state <= in ? S4 : S0;\n\t\t\tS4: state <= in ? S5 : S0;\n\t\t\tS5: state <= in ? S6 : SDISC;\n\t\t\tS6: state <= in ? SERR : SFLAG;\n\t\t\tSERR: state <= in ? SERR : S0;\n\t\t\tSFLAG: state <= in ? S1 : S0;\n\t\t\tSDISC: state <= in ? S1 : S0;\n\t\t\tdefault: state <= 'x;\n\t\tendcase\n\t\t\n\t\tif (reset) state <= S0;\n\tend\n\t\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput clk,\n\tinput reset,\n\tinput in,\n\toutput disc,\n\toutput flag,\n\toutput err);\n\t\n\tparameter [3:0] S0=0, S1=1, S2=2, S3=3, S4=4, S5=5, S6=6, SERR=7, SDISC=8, SFLAG=9;\n\treg [3:0] state, next;\n\n\tassign disc = state == SDISC;\n\tassign flag = state == SFLAG;\n\tassign err = state == SERR;\n\t\n\talways @(posedge clk) begin\n\t\tcase (state)\n\t\t\tS0: state <= in ? S1 : S0;\n\t\t\tS1: state <= in ? S2 : S0;\n\t\t\tS2: state <= in ? S3 : S0;\n\t\t\tS3: state <= in ? S4 : S0;\n\t\t\tS4: state <= in ? S5 : S0;\n\t\t\tS5: state <= in ? S6 : SDISC;\n\t\t\tS6: state <= in ? SERR : SFLAG;\n\t\t\tSERR: state <= in ? SERR : S0;\n\t\t\tSFLAG: state <= in ? S1 : S0;\n\t\t\tSDISC: state <= in ? S1 : S0;\n\t\t\tdefault: state <= 'x;\n\t\tendcase\n\t\t\n\t\tif (reset) state <= S0;\n\tend\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic reset, in\n);\n\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\tin <= 0;\n\t\t@(posedge clk);\n\t\trepeat(800) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 31);\n\t\t\tin <= |($random&7);\n\t\tend\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_disc;\n\t\tint errortime_disc;\n\t\tint errors_flag;\n\t\tint errortime_flag;\n\t\tint errors_err;\n\t\tint errortime_err;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic in;\n\tlogic disc_ref;\n\tlogic disc_dut;\n\tlogic flag_ref;\n\tlogic flag_dut;\n\tlogic err_ref;\n\tlogic err_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,in,disc_ref,disc_dut,flag_ref,flag_dut,err_ref,err_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset,\n\t\t.in );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.in,\n\t\t.disc(disc_ref),\n\t\t.flag(flag_ref),\n\t\t.err(err_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.in,\n\t\t.disc(disc_dut),\n\t\t.flag(flag_dut),\n\t\t.err(err_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_disc) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"disc\", stats1.errors_disc, stats1.errortime_disc);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"disc\");\n\t\tif (stats1.errors_flag) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"flag\", stats1.errors_flag, stats1.errortime_flag);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"flag\");\n\t\tif (stats1.errors_err) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"err\", stats1.errors_err, stats1.errortime_err);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"err\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { disc_ref, flag_ref, err_ref } === ( { disc_ref, flag_ref, err_ref } ^ { disc_dut, flag_dut, err_dut } ^ { disc_ref, flag_ref, err_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (disc_ref !== ( disc_ref ^ disc_dut ^ disc_ref ))\n\t\tbegin if (stats1.errors_disc == 0) stats1.errortime_disc = $time;\n\t\t\tstats1.errors_disc = stats1.errors_disc+1'b1; end\n\t\tif (flag_ref !== ( flag_ref ^ flag_dut ^ flag_ref ))\n\t\tbegin if (stats1.errors_flag == 0) stats1.errortime_flag = $time;\n\t\t\tstats1.errors_flag = stats1.errors_flag+1'b1; end\n\t\tif (err_ref !== ( err_ref ^ err_dut ^ err_ref ))\n\t\tbegin if (stats1.errors_err == 0) stats1.errortime_err = $time;\n\t\t\tstats1.errors_err = stats1.errors_err+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "bugs_mux2", "prompt": "module top_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n", "canonical_solution": "\n\t// assign out = (~sel & a) | (sel & b);\n    assign out = sel ? a : b;\n\t\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module (\n\tinput sel,\n\tinput [7:0] a,\n\tinput [7:0] b,\n\toutput reg [7:0] out\n);\n\n\t// assign out = (~sel & a) | (sel & b);\n    assign out = sel ? a : b;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput logic sel,\n\toutput logic [7:0] a, b,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable\t\n);\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\n\tinitial begin\n\t\t{a, b, sel} <= '0;\n\t\t@(negedge clk) wavedrom_start(\"\");\n\t\t\t@(posedge clk, negedge clk) {a,b,sel} <= {8'haa, 8'hbb, 1'b0};\n\t\t\t@(posedge clk, negedge clk) {a,b,sel} <= {8'haa, 8'hbb, 1'b0};\n\t\t\t@(posedge clk, negedge clk) {a,b,sel} <= {8'haa, 8'hbb, 1'b1};\n\t\t\t@(posedge clk, negedge clk) {a,b,sel} <= {8'haa, 8'hbb, 1'b0};\n\t\t\t@(posedge clk, negedge clk) {a,b,sel} <= {8'haa, 8'hbb, 1'b1};\n\t\t\t@(posedge clk, negedge clk) {a,b,sel} <= {8'haa, 8'hbb, 1'b1};\n\t\t\t\n\t\t\t@(posedge clk, negedge clk) {a, b} <= {8'hff, 8'h00}; sel <= 1'b0;\n\t\t\t@(posedge clk, negedge clk) sel <= 1'b0;\n\t\t\t@(posedge clk, negedge clk) sel <= 1'b1;\n\t\t\t@(posedge clk, negedge clk) sel <= 1'b0;\n\t\t\t@(posedge clk, negedge clk) sel <= 1'b1;\n\t\t\t@(posedge clk, negedge clk) sel <= 1'b1;\n\t\twavedrom_stop();\n\t\t\n\t\trepeat(100) @(posedge clk, negedge clk)\n\t\t\t{a,b,sel} <= $urandom;\n\t\t$finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_out;\n\t\tint errortime_out;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic sel;\n\tlogic [7:0] a;\n\tlogic [7:0] b;\n\tlogic [7:0] out_ref;\n\tlogic [7:0] out_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,sel,a,b,out_ref,out_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.sel,\n\t\t.a,\n\t\t.b );\n\treference_module good1 (\n\t\t.sel,\n\t\t.a,\n\t\t.b,\n\t\t.out(out_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.sel,\n\t\t.a,\n\t\t.b,\n\t\t.out(out_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_out) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"out\", stats1.errors_out, stats1.errortime_out);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"out\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { out_ref } === ( { out_ref } ^ { out_dut } ^ { out_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (out_ref !== ( out_ref ^ out_dut ^ out_ref ))\n\t\tbegin if (stats1.errors_out == 0) stats1.errortime_out = $time;\n\t\t\tstats1.errors_out = stats1.errors_out+1'b1; end\n\n\tend\nendmodule\n"}
{"task_id": "review2015_count1k", "prompt": "module top_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n", "canonical_solution": "\t\n\talways @(posedge clk)\n\t\tif (reset || q == 999)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n", "test": "`timescale 1 ps/1 ps\n`define OK 12\n`define INCORRECT 13\nmodule reference_module(\n\tinput clk,\n\tinput reset,\n\toutput reg [9:0] q);\n\t\n\talways @(posedge clk)\n\t\tif (reset || q == 999)\n\t\t\tq <= 0;\n\t\telse\n\t\t\tq <= q+1;\n\t\nendmodule\n\n\nmodule stimulus_gen (\n\tinput clk,\n\toutput reg reset,\n\toutput reg[511:0] wavedrom_title,\n\toutput reg wavedrom_enable,\n\tinput tb_match\n);\n\ttask reset_test(input async=0);\n\t\tbit arfail, srfail, datafail;\n\t\n\t\t@(posedge clk);\n\t\t@(posedge clk) reset <= 0;\n\t\trepeat(3) @(posedge clk);\n\t\n\t\t@(negedge clk) begin datafail = !tb_match ; reset <= 1; end\n\t\t@(posedge clk) arfail = !tb_match;\n\t\t@(posedge clk) begin\n\t\t\tsrfail = !tb_match;\n\t\t\treset <= 0;\n\t\tend\n\t\tif (srfail)\n\t\t\t$display(\"Hint: Your reset doesn't seem to be working.\");\n\t\telse if (arfail && (async || !datafail))\n\t\t\t$display(\"Hint: Your reset should be %0s, but doesn't appear to be.\", async ? \"asynchronous\" : \"synchronous\");\n\t\t// Don't warn about synchronous reset if the half-cycle before is already wrong. It's more likely\n\t\t// a functionality error than the reset being implemented asynchronously.\n\t\n\tendtask\n\n\n// Add two ports to module stimulus_gen:\n//    output [511:0] wavedrom_title\n//    output reg wavedrom_enable\n\n\ttask wavedrom_start(input[511:0] title = \"\");\n\tendtask\n\t\n\ttask wavedrom_stop;\n\t\t#1;\n\tendtask\t\n\n\n\t\n\tinitial begin\n\t\treset <= 1;\n\t\twavedrom_start(\"Synchronous reset\");\n\t\treset_test();\n\t\trepeat(5) @(posedge clk);\n\t\twavedrom_stop();\n\n\t\treset <= 0;\n\t\t\n\t\trepeat(989) @(negedge clk);\n\t\twavedrom_start(\"Wrap around behaviour\");\n\t\trepeat(14)@(posedge clk);\n\t\twavedrom_stop();\n\t\t\n\t\n\t\t\n\t\trepeat(2000) @(posedge clk, negedge clk) begin\n\t\t\treset <= !($random & 127);\n\t\tend\n\t\treset <= 0;\n\t\trepeat(2000) @(posedge clk);\n\n\t\t#1 $finish;\n\tend\n\t\nendmodule\n\nmodule tb();\n\n\ttypedef struct packed {\n\t\tint errors;\n\t\tint errortime;\n\t\tint errors_q;\n\t\tint errortime_q;\n\n\t\tint clocks;\n\t} stats;\n\t\n\tstats stats1;\n\t\n\t\n\twire[511:0] wavedrom_title;\n\twire wavedrom_enable;\n\tint wavedrom_hide_after_time;\n\t\n\treg clk=0;\n\tinitial forever\n\t\t#5 clk = ~clk;\n\n\tlogic reset;\n\tlogic [9:0] q_ref;\n\tlogic [9:0] q_dut;\n\n\tinitial begin \n\t\t$dumpfile(\"wave.vcd\");\n\t\t$dumpvars(1, stim1.clk, tb_mismatch ,clk,reset,q_ref,q_dut );\n\tend\n\n\n\twire tb_match;\t\t// Verification\n\twire tb_mismatch = ~tb_match;\n\t\n\tstimulus_gen stim1 (\n\t\t.clk,\n\t\t.* ,\n\t\t.reset );\n\treference_module good1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_ref) );\n\t\t\n\ttop_module top_module1 (\n\t\t.clk,\n\t\t.reset,\n\t\t.q(q_dut) );\n\n\t\n\tbit strobe = 0;\n\ttask wait_for_end_of_timestep;\n\t\trepeat(5) begin\n\t\t\tstrobe <= !strobe;  // Try to delay until the very end of the time step.\n\t\t\t@(strobe);\n\t\tend\n\tendtask\t\n\n\t\n\tfinal begin\n\t\tif (stats1.errors_q) $display(\"Hint: Output '%s' has %0d mismatches. First mismatch occurred at time %0d.\", \"q\", stats1.errors_q, stats1.errortime_q);\n\t\telse $display(\"Hint: Output '%s' has no mismatches.\", \"q\");\n\n\t\t$display(\"Hint: Total mismatched samples is %1d out of %1d samples\\n\", stats1.errors, stats1.clocks);\n\t\t$display(\"Simulation finished at %0d ps\", $time);\n\t\t$display(\"Mismatches: %1d in %1d samples\", stats1.errors, stats1.clocks);\n\tend\n\t\n\t// Verification: XORs on the right makes any X in good_vector match anything, but X in dut_vector will only match X.\n\tassign tb_match = ( { q_ref } === ( { q_ref } ^ { q_dut } ^ { q_ref } ) );\n\t// Use explicit sensitivity list here. @(*) causes NetProc::nex_input() to be called when trying to compute\n\t// the sensitivity list of the @(strobe) process, which isn't implemented.\n\talways @(posedge clk, negedge clk) begin\n\n\t\tstats1.clocks++;\n\t\tif (!tb_match) begin\n\t\t\tif (stats1.errors == 0) stats1.errortime = $time;\n\t\t\tstats1.errors++;\n\t\tend\n\t\tif (q_ref !== ( q_ref ^ q_dut ^ q_ref ))\n\t\tbegin if (stats1.errors_q == 0) stats1.errortime_q = $time;\n\t\t\tstats1.errors_q = stats1.errors_q+1'b1; end\n\n\tend\nendmodule\n"}
